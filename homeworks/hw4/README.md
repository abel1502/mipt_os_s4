# Подготовка и вызов `do_syscall` (1 балл)

В файле [`syscall.S`](arch/x86/syscall.S) реализован простой обработчик инструкции `syscall`. Настройку соответствующих MSR можно найти в [`x86.c`](arch/x86/x86.c). Пока это просто заглушка, которая просто возвращается обратно в процесс. Вам нужно реализовать полноценную входную точку для системных вызовов: сформировать `arch_regs_t` (объявлен в [`arch.h`](arch/x86/arch.h)) на стеке и передать их в `do_syscall`. Также смотрите на комментарий-подсказку к `syscall_entry`.

Если вы пишете всё с нуля, достаточно поддержать таблицу сисколлов и их вызов через инструкцию `syscall`.

# Preemptive multitasking (1 балл)
Вытеснение процессов – неотъемлемая часть современных ОС. В этом задании нужно обеспечить переключение между процессами раз в 10 тиков таймера. Для реализации будет удобно менять функцию `sched_timer_tick`, которая уже вызывается в обработчике прерывания от таймера.

# Реализация `sys_sleep` (1 балл)
Нужно реализовать системный вызов `sys_sleep(sleep_ms)`, который возвращает управление в процесс не раньше, чем через `sleep_ms` миллисекунд.

# Реализация `sys_exit` (1 балл)
`sys_exit(exitcode)` вызывается процессом при его завершении. Он должен перевести процесс в состояние `TASK_ZOMBIE` до того момента, как родитель запросит его состояние через `sys_wait`.
Несмотря на то, что сам системный вызов прост в исполнении, для его реализации потребуется написать функцию `vmem_destroy`, которая освободит все страницы, занятые структурой `vmem_t`. Обратите внимание, что также нужно освободить страницы, используемые для самих таблиц.

# Реализация `sys_wait` (1 балла + 1 балл бонус)
Полная сигнатура: `int64_t sys_wait(pid_t pid, int* status)`. Этот системный вызов должен зависать до того момента, пока ребёнок с заданным `pid` не будет завершён. Код возврата нужно записать в пользовательское пространство по заданному указателю.

Не забудьте проверить, что этот указатель ссылается на валидный регион памяти. Сейчас это можно сделать, например, проходя по всем `vmem_area_t`. Однако если вы сильны духом, можете реализовать схему аналогичную той, что используется в Linux. Про неё можно почитать [здесь](https://t.me/carzil_channel/65) или в исходниках ядра. Это будет оцениваться дополнительный балл.

# Реализация `sys_fork` (1 балл + 1 балл бонус)
В этом задании вам предстоит реализовать системный вызов `fork`. Он должен создавать точный клон текущего процесса: должны быть скопированы регистры, стек и выделенная процессом память. После выхода в родителе должен быть возвращён PID ребёнка. А в ребёнке нужно вернуть 0.

Кроме самого системного вызова вам также потребуется реализовать функцию клонирования текущего адресного пространства `vmem_clone_from_current` (обратите внимание, что пространство-источник предполагается активным, поэтому вы можете напрямую обращаться к его виртуальным адресам), а также функцию трансляции виртуального адреса в физический `translate_address`.

Дополнительный балл получат решения, которые поддерживают copy-on-write клонирование адресного пространства.
