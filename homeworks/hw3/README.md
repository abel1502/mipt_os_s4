# Frame allocator (2 балла)
Сейчас в HellOS [реализован](mm/frame_alloc.h) элементарный аллокатор физических фреймов, основанный на связном списке свободных фреймов. Однако у него есть принципиальный недостаток: он не позволяет выделить более одной страницы непрерывно в памяти. В этом задании вам предлагается исправить этот недочёт.

Оценка задания производится следующим образом:
* В 1 балл будут оцениваться решения, позволяющие выделять непрерывно N фреймов (N можно ограничить сверху).
* В 2 балла будут оцениваться решения, выделяющие и освобождающие фреймы амортизировано за `O(1)`.

# Object allocator (1 балл)
В следующих домашних заданиях нам потребуется выделять большое количество «маленьких объектов». Это, например, структуры, описывающие процессы, файловые дескрипторы итд. Такие объекты будут довольно маленькими (несколько десятков байт), поэтому использовать frame allocator для таких объектов слишком расточительно. В этом задании вам предлагается реализовать простой аллокатор, позволяющий «нарезать» страницы, выдаваемые frame allocator'ом на объекты заданного типа.

Код для задания можно найти в [mm/obj.h](mm/obj.h)

Аллокатор для объектов объявляется следующими макросами:
```c
OBJ_ALLOC_DEFINE(task_alloc, struct task);
OBJ_ALLOC_DECLARE(task_alloc);
```

Аллокация объектов:
```c
struct task* task = object_alloc(&task_alloc);
if (task != NULL) {
    // ...
}
```
Для того, чтобы в будущем избежать false sharing, выравнивайте возвращаемые указатели по размеру кэш-линии (задаётся константой `CACHE_LINE_SIZE_BYTES`).

Освобождение:
```c
object_free(&task_alloc, task);
```

# On-demand paging (2 балла)
В HellOS есть структура [`vmem_t`](mm/vmem.h), отвечающая за адресное пространство. Основная задача этой структуры — выделять виртуальные адреса и хранить их отображение в физические фреймы. Для выделения диапазона адресов используется функция `vmem_alloc_pages`, для освобождения – `vmem_free_pages`. Самая примитивная реализация `vmem_alloc_pages` выделяет всю память сразу. Однако современные ОС не выделяют всю запрошенную память сразу, а используют on-demand paging:
1. При аллокации памяти создаётся объект-регион (с помощью object allocator) о том, что регион виртуальных адресов был запрошен процессом.
1. При первом обращении к выделенной памяти случится `#PF`, т.к. она не добавлена в страницы таблиц.
1. Внутри `#PF` ОС проверяет, что страница принадлежит одному из запрошенных регионов, выделяет странницу с помощью frame allocator'а и добавляет её в маппинг.

Если страницы нет в маппинге, то сейчас достаточно будет вызвать `panic`. Потом в этом месте будет происходить что-то более сложное (например, завершение процесса или отправка `SIGSEGV`).

Оценка задания производится следующим образом:
* В 1 балл будут оцениваться решения, не поддерживающие on-demand paging.
* В 2 балла будут оцениваться решения, поддерживающие on-demand paging.
